/**
 * jsfu
 * Copyright(c) 2012 Charlie Rudenstål <charlie4@gmail.com>
 * MIT Licensed 
 */

/**
 * Dependencies
 */

var jsp    = require('uglify-js').parser
  , pro    = require('uglify-js').uglify;

/**
 * Export jsfu
 */

exports = module.exports = jsfu;

/**
 * Transpile Javascript source with extensions
 * Will return native Javascript
 * @param  string source Extended Javascript source
 * @return string source Transpiled Javascript source 
 */
function jsfu(source) {

	if(!source) throw new Error('Sadly, no sign of source. jsfu demands source.');

	//var code = options.code || throw new Exeception('jsfu demands source');

	// Remove comments and their new lines
	// to make debug output a bit easier to read
	source = source.replace(/\/\/\s.*\s?/g, "");


	/**
	 * Function Definition
	 * -----------------------------------
	 * Will turn function definitions:
	 * 
	 * 		var x = (a, b) => { console.log(a + b) };
	 *
	 * into:
	 *  
	 *  	var x = function(a, b) { console.log(a + b); };
	 * 
	 * And turn anonymous function definitions:
	 *
	 * 		foo(123, (a, b) => { x(a, b) }, 123);
	 *
	 * into:
	 * 
	 * 		foo(123, function(a, b) { x(a, b) }, 123);
	 * 
	 */			
	function transformFunc(source) {

		/**
		 * Arrow Alias
		 * -----------
		 * Will alias -> to =>
		 */
		function transformArrowAlias(source) {
			return source.replace(/->/g, '=>');
		}
		/**
		 * Function Definition without Parameters
		 * --------------------------------------
		 * Will turn: 
		 * 		
		 * 		writeAsync('text', => { x(2); });
		 * 		
		 * into:
		 *  
		 * 		writeAsync('text', function() { x(2); });
		 * 		
		 */
		function transformFuncArrow(source) {
			
			return source.replace(/=>/g, 'function()');
		}

		/**
		 * Function Definition with Parameters
		 * -----------------------------------
		 * Will transform output generated by transformFuncArrow above:
		 * 
		 * 		foo = (a, b) function()
		 *
		 * into:
		 *  
		 * 		foo = function(a, b)
		 * 		
		 * which combined with transformFuncArrow above allows for:
		 * 		
		 * 		foo = (a, b) => { b(); };
		 *
		 * and
		 *
		 * 		bar(123, (a, b) => { x(a); });
		 * 		
		 */	
		function transformFuncParameters() {
		
		    return source.replace(/(\(([^()]*)\))\s+function\(\)/g, 'function($2)');
			//		      match params ^           ^ search for function generated above
			//            accept anything
			//            except surrounding ()
		}

		source = transformArrowAlias(source);
		source = transformFuncArrow(source);
		source = transformFuncParameters(source);
		return source;
	}

	/**
	 * Async Call: Assignment to Callback
	 * ----------------------------------
	 * Will turn
	 *
	 * 		var foo = bar(123, §, 123);
	 *   	x(foo);
	 * 
	 * into
	 *
	 * 		bar(123, function(foo) { x(foo); }, 123);
	 *
	 * Async Wrapping
	 * --------------
	 *
	 * Without async wrapping:
	 * 
	 * 	 	var r = A($);
	 * 	 	var r = C($);
	 * 	 	var r = B($);
	 *
	 * This will run A first
	 * When A is completed C will run
	 * When C is completed B will run
	 * 
	 * With async wrapping:
	 * 
	 * 		function foo() {
	 * 			var r = A($);
	 * 		    var r = C($); 
	 * 		}
	 * 		foo();
	 *      var r = B($);
	 * 
	 * This will run A and B in parallell
	 * When A is completed C will run
	 * 
	 */
	function transformAsync(source) {

		/**
		 * match:         [matched line and all lines below this line until }]
		 * variable:      x
		 * preFunction:   f(
		 * postFunction:  );
		 * callbackCode:  [all code below this line]
		 * offsetStart:   first character index of this matched line
		 */ 
		replacer = function(match, variable, preFunction, postFunction, callbackCode, functionWrapper, contextOffsetStart) {
			var isWrapped = (functionWrapper == "}");

			// Step 2: Retrieve all code below this line that should
			// 		   be called asynchronously
			// var contextOffsetEnd = contextOffsetStart + match.length;
			// var callbackOffsetStart = contextOffsetEnd - callbackCode.length;
			var callbackOffsetStart = match.length - callbackCode.length;
			var codeBelow = match.substring(callbackOffsetStart);

			// If thie async call is wrapped in a function
			// codeBelow will contain everything in that function
			// below this call. Code below will also include the 
			// end bracket } of the function. Be sure to remove that
			if (isWrapped) {
				codeBelow = codeBelow.slice(0, -1); 
			}

			// Step 3: Parse the code below recursively
			codeBelow = transformAsync(codeBelow);
			
			// Step 4: Replace with f(function(x) { [...] });
			var newCode = preFunction + 'function(' + variable + ') ' +
						  '{' + codeBelow + '}' + 
						  postFunction;

			// If this async call is wrapped in a function
			// we removed the last } of that function earlier,
			// now add it again
			if(isWrapped) {			
				newCode += "}";
			}

			return newCode;
		};


		// Search for any var x = f(§); that are wrapped inside a function
		source = source.replace(/var (.+) = (.+)§(.+)([.\s\S]*?)(})/g, replacer);

		// Search for any var x = f($); that are not wrapped inside a function
		source = source.replace(/var (.+) = (.+)§(.+)([.\s\S]*)/g, replacer);

		return source;
	};

	/**
	 * Run it through uglify.js to get nice indentation
	 * after all formatting. Will also escape '</script' using
	 * the inline-script option of uglify.js - if this
	 * code is ever to be used in a browser environment
	 */
	function beautify(source) { 
		try {
			var ast = jsp.parse(source);
			return pro.gen_code(ast, {beautify: true, inline_script: true});
		} catch(e) {
			// Ignore beautification on parse errors
			return source;
		}
	}

	source = transformFunc(source);
	source = transformAsync(source);
	source = beautify(source);

	return source;
}


/**
 * TODO
 * ----
 * Write something nice to simplify this kind of code:
 * 	
 * 	  	code = transformArrowAlias(code);
 *	    code = transformFuncArrow(code);
 *	    code = transformFuncParameters(code);
 *
 *  or equally:
 * 
 * 		transformFuncParameters(transformFuncArrow(transformArrowAlias(code)));
 *
 *  Perhaps with a pipe syntax to indicate that the 
 *  returned value should be pushed into the right hand function:
 *
 * 		code = code
 * 				| transformArrowAlias  
 * 			    | transformFuncArrow  
 * 			    | transformFuncParameters
 *
 *		Would turn:   "Hello World" | alert
 *			  into:   alert("Hello world")
 * 
 *	or use a <= symbol to indicate that the returned value
 *	should be pushed into the left hand function:
 *
 * 		code = transformFuncParameters 
 * 		       <= transformFuncArrow 
 * 		       <= transformArrowAlias
 * 		       <= code
 *
 * 		Would turn:   alert <= "Hello World"
 * 			  into:   alert("Hello world");
 * 		       
 */
