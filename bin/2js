#!/usr/bin/env node
var fs     = require('fs')
  , vm     = require('vm')
  , jsp    = require('uglify-js').parser
  , pro    = require('uglify-js').uglify
;

var code = fs.readFileSync('./bin/test.js', 'utf-8');

/**
 * TODO
 * ----
 * Write something nice to simplify this kind of code:
 * 	
 * 	  	code = transformArrowAlias(code);
 *	    code = transformFuncArrow(code);
 *	    code = transformFuncParameters(code);
 *
 *  or equally:
 * 
 * 		transformFuncParameters(transformFuncArrow(transformArrowAlias(code)));
 *
 *  Perhaps with a pipe syntax to indicate that the 
 *  returned value should be pushed into the right hand function:
 *
 * 		code = code
 * 				| transformArrowAlias  
 * 			    | transformFuncArrow  
 * 			    | transformFuncParameters
 *
 *		Would turn:   "Hello World" | alert
 *			  into:   alert("Hello world")
 * 
 *	or use a <= symbol to indicate that the returned value
 *	should be pushed into the left hand function:
 *
 * 		code = transformFuncParameters 
 * 		       <= transformFuncArrow 
 * 		       <= transformArrowAlias
 * 		       <= code
 *
 * 		Would turn:   alert <= "Hello World"
 * 			  into:   alert("Hello world");
 * 		       
 */

// Remove comments and their new lines
// to make debug output a bit easier to read
code = code.replace(/\/\/\s.*\s?/g, "");


/**
 * Function Definition
 * -----------------------------------
 * Will turn function definitions:
 * 
 * 		var x = (a, b) => { console.log(a + b) };
 *
 * into:
 *  
 *  	var x = function(a, b) { console.log(a + b); };
 * 
 * And turn anonymous function definitions:
 *
 * 		foo(123, (a, b) => { x(a, b) }, 123);
 *
 * into:
 * 
 * 		foo(123, function(a, b) { x(a, b) }, 123);
 * 
 */			
function transformFunc(code) {

	/**
	 * Arrow Alias
	 * -----------
	 * Will alias -> to =>
	 */
	function transformArrowAlias(code) {
		return code.replace(/->/g, '=>');
	}
	/**
	 * Function Definition without Parameters
	 * --------------------------------------
	 * Will turn: 
	 * 		
	 * 		writeAsync('text', => { x(2); });
	 * 		
	 * into:
	 *  
	 * 		writeAsync('text', function() { x(2); });
	 * 		
	 */
	function transformFuncArrow(code) {
		
		return code.replace(/=>/g, 'function()');
	}

	/**
	 * Function Definition with Parameters
	 * -----------------------------------
	 * Will transform output generated by transformFuncArrow above:
	 * 
	 * 		foo = (a, b) function()
	 *
	 * into:
	 *  
	 * 		foo = function(a, b)
	 * 		
	 * which combined with transformFuncArrow above allows for:
	 * 		
	 * 		foo = (a, b) => { b(); };
	 *
	 * and
	 *
	 * 		bar(123, (a, b) => { x(a); });
	 * 		
	 */	
	function transformFuncParameters() {
	
	    return code.replace(/(\(([^()]*)\))\s+function\(\)/g, 'function($2)');
		//		      match params ^           ^ search for function generated above
		//            accept anything
		//            except surrounding ()
	}

	code = transformArrowAlias(code);
	code = transformFuncArrow(code);
	code = transformFuncParameters(code);
	return code;
}

/**
 * Async Call: Assignment to Callback
 * ----------------------------------
 * Will turn
 *
 * 		var foo = bar(123, ยง, 123);
 *   	x(foo);
 * 
 * into
 *
 * 		bar(123, function(foo) { x(foo); }, 123);
 *
 * Async Wrapping
 * --------------
 *
 * Without async wrapping:
 * 
 * 	 	var r = A($);
 * 	 	var r = C($);
 * 	 	var r = B($);
 *
 * This will run A first
 * When A is completed C will run
 * When C is completed B will run
 * 
 * With async wrapping:
 * 
 * 		function foo() {
 * 			var r = A($);
 * 		    var r = C($); 
 * 		}
 * 		foo();
 *      var r = B($);
 * 
 * This will run A and B in parallell
 * When A is completed C will run
 * 
 */
function transformAsync(code) {

	/**
	 * match:         [matched line and all code below this line]
	 * variable:      x
	 * preFunction:   f(
	 * postFunction:  );
	 * callbackCode:  [all code below this line]
	 * offsetStart:   first character index of this matched line
	 */ 
	replacer = function(match, variable, preFunction, postFunction, callbackCode, functionWrapper, contextOffsetStart) {
		var isWrapped = (functionWrapper == "}");

		// Step 2: Retrieve all code below this line that should
		// 		   be called asynchronously
		// var contextOffsetEnd = contextOffsetStart + match.length;
		// var callbackOffsetStart = contextOffsetEnd - callbackCode.length;
		var callbackOffsetStart = match.length - callbackCode.length;
		var codeBelow = match.substring(callbackOffsetStart);

		// If thie async call is wrapped in a function
		// codeBelow will contain everything in that function
		// below this call. Code below will also include the 
		// end bracket } of the function. Be sure to remove that
		if (isWrapped) {
			codeBelow = codeBelow.slice(0, -1); 
		}

		// Step 3: Parse the code below recursively
		codeBelow = transformAsync(codeBelow);
		
		// Step 4: Replace with f(function(x) { [...] });
		var newCode = preFunction + 'function(' + variable + ') ' +
					  '{' + codeBelow + '}' + 
					  postFunction;

		// If this async call is wrapped in a function
		// we removed the last } of that function earlier,
		// now add it again
		if(isWrapped) {			
			newCode += "}";
		}

		return newCode;
	};


	// Search for any var x = f(ยง); that are wrapped inside a function
	code = code.replace(/var (.+) = (.+)ยง(.+)([.\s\S]*?)(})/g, replacer);

	// Search for any var x = f($); that are not wrapped inside a function
	code = code.replace(/var (.+) = (.+)ยง(.+)([.\s\S]*)/g, replacer);

	return code;
};

/**
 * Run it through uglify.js to get nice indentation
 * after all formatting. Will also escape '</script' using
 * the inline-script option of uglify.js - if this
 * code is ever to be used in a browser environment
 */
function beautify(code) { 
	try {
		var ast = jsp.parse(code);
		return pro.gen_code(ast, {beautify: true, inline_script: true});
	} catch(e) {
		// Ignore beautification on parse errors
		return code;
	}
}


code = transformFunc(code);
code = transformAsync(code);

code = beautify(code);

/**
 * Output generated code and execute code
 */
console.log(code);
console.log(Array(40).join('-'));
try {
	vm.runInNewContext(code, {console: console, setTimeout: setTimeout});
} catch (e) {
	console.log(e);
}